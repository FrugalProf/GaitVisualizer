<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gait Analysis Tool - Prof. Fedel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f8fafc; color: #334155; }
        
        /* Layout */
        .main-container { width: 98%; max-width: 1400px; margin: 0 auto; padding-bottom: 80px; }
        .card { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); padding: 20px; border: 1px solid #e2e8f0; display: flex; flex-direction: column; margin-bottom: 24px; }
        
        /* Tabs */
        .tab-btn { padding: 10px 24px; border-radius: 8px 8px 0 0; font-weight: 600; font-size: 0.9rem; border: 1px solid transparent; border-bottom: none; cursor: pointer; transition: all 0.2s; }
        .tab-active { background-color: white; border-color: #cbd5e1; color: #1e40af; border-top: 3px solid #1e40af; }
        .tab-inactive { background-color: #f1f5f9; color: #64748b; }
        .tab-inactive:hover { background-color: #e2e8f0; }

        /* Graph Switcher */
        .graph-toggle-btn { 
            display: flex; align-items: center; justify-content: center;
            padding: 6px 14px; 
            border: 1px solid #cbd5e1; 
            background: #f8fafc; 
            color: #64748b; 
            font-weight: 600; 
            font-size: 0.8rem; 
            cursor: pointer; 
            border-radius: 6px;
            transition: all 0.2s;
            min-width: 100px;
        }
        .graph-toggle-active { 
            background: #1e40af; 
            color: white; 
            border-color: #1e40af; 
            box-shadow: 0 2px 4px rgba(30, 64, 175, 0.2);
        }

        /* Canvas Container */
        .canvas-scroll-container { 
            overflow-x: auto; 
            border: 1px solid #e5e7eb; 
            border-radius: 6px; 
            background: #fff; 
            /* Padding adjusted as canvas now manages its own internal margins better */
            padding: 10px; 
        }

        /* Tables */
        .stat-table th { background-color: #f1f5f9; color: #475569; font-weight: 700; font-size: 0.7rem; text-transform: uppercase; padding: 8px; border-bottom: 2px solid #e2e8f0; }
        .stat-table td { padding: 8px; font-size: 0.85rem; border-bottom: 1px solid #f1f5f9; color: #334155; }
        .stat-table tr:last-child td { border-bottom: none; }
        
        .no-data { display: flex; align-items: center; justify-content: center; height: 100%; color: #94a3b8; font-style: italic; background: #f8fafc; border-radius: 4px; border: 1px dashed #cbd5e1; }
        
        /* Modal */
        .modal { display: none; position: fixed; z-index: 50; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border-radius: 8px; width: 700px; max-width: 95%; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    </style>
</head>
<body class="p-4 text-slate-800 bg-slate-50">

<div class="main-container">
    
    <header class="flex justify-between items-center mb-6 pb-4 border-b border-slate-200">
        <div>
            <h1 class="text-3xl font-bold text-slate-900">Gait Analysis Dashboard</h1>
            <p class="text-slate-500 mt-1">Created by Professor Fedel</p>
        </div>
        <button onclick="toggleModal()" class="bg-white border border-blue-200 text-blue-700 hover:bg-blue-50 font-semibold py-2 px-4 rounded shadow-sm flex items-center gap-2 text-sm">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
            Instructions
        </button>
    </header>

    <div class="flex pl-1">
        <button id="tab-set1" onclick="switchTab('set1')" class="tab-btn tab-active">Data Set 1</button>
        <button id="tab-set2" onclick="switchTab('set2')" class="tab-btn tab-inactive">Data Set 2</button>
    </div>

    <div class="bg-white rounded-lg rounded-tl-none shadow-sm p-6 mb-8 border border-slate-300">
        <div class="flex flex-col md:flex-row justify-between items-end mb-4 gap-4">
            <div class="w-full md:w-1/3">
                <label class="block text-xs font-bold text-slate-500 uppercase tracking-wide mb-1">Dataset Label</label>
                <input type="text" id="datasetLabel" class="w-full p-2 border border-slate-300 rounded text-sm font-semibold text-slate-700 focus:ring-2 focus:ring-blue-500 outline-none" placeholder="e.g. Pre-Op Condition">
            </div>
            <div class="flex items-center gap-3">
                <button onclick="loadDemoData()" class="text-blue-600 hover:text-blue-800 text-sm font-medium underline decoration-dotted">Load Demo Data</button>
                <button onclick="processData()" class="bg-slate-900 hover:bg-slate-800 text-white font-bold py-2 px-6 rounded-lg shadow transition text-sm">
                    UPDATE ANALYSIS
                </button>
            </div>
        </div>
        
        <label class="block text-xs font-bold text-slate-500 uppercase tracking-wide mb-1">Raw Data Input (A3:H31)</label>
        <textarea id="rawData" class="w-full h-24 p-3 border border-slate-300 rounded-lg font-mono text-xs focus:ring-2 focus:ring-blue-500 outline-none" placeholder="Paste range A3:H31 here..."></textarea>
    </div>

    <div id="resultsArea" class="hidden">
        
        <div class="flex items-center justify-between mb-4 bg-white p-3 rounded-lg border border-slate-200 shadow-sm sticky top-2 z-20">
            <div class="flex items-center gap-2">
                <span class="text-xs font-bold text-slate-400 uppercase mr-2">Active View:</span>
                <button id="toggle-set1" onclick="switchTab('set1')" class="graph-toggle-btn graph-toggle-active">Data Set 1</button>
                <button id="toggle-set2" onclick="switchTab('set2')" class="graph-toggle-btn">Data Set 2</button>
            </div>
            <div class="text-sm font-bold text-blue-900" id="displayLabel"></div>
        </div>

        <div class="card">
            <div class="mb-4 border-b pb-2 flex justify-between items-center">
                <div>
                    <h3 class="text-lg font-bold text-slate-800">Gait Cycle Visualization</h3>
                    <div class="text-xs text-slate-500 mt-1 flex gap-3">
                        <div class="flex items-center"><span id="legendStance" class="w-3 h-3 mr-1 rounded-sm"></span> Stance</div>
                        <div class="flex items-center"><span id="legendSwing" class="w-3 h-3 mr-1 rounded-sm border border-slate-300"></span> Swing</div>
                    </div>
                </div>
                <label class="flex items-center cursor-pointer select-none text-sm text-slate-600 bg-slate-50 px-3 py-1.5 rounded border border-slate-200 hover:bg-slate-100">
                    <input type="checkbox" id="colorSchemeToggle" class="mr-2" onchange="processData()" checked> Use Alternate Colors (Blue/Maroon)
                </label>
            </div>
            <div class="canvas-scroll-container">
                <canvas id="gaitVisualizerCanvas" height="420"></canvas>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <div class="flex flex-col h-full">
                <div class="card h-full mb-0">
                    <div class="mb-2 border-b pb-1">
                        <h3 class="text-sm font-bold text-slate-800">Spatial Means (cm)</h3>
                        <p class="text-[10px] text-slate-500">Error Bars = 95% CI. Fixed scale.</p>
                    </div>
                    <div class="h-64 w-full relative mb-2" id="containerSpatialBar">
                        <canvas id="spatialBarChart"></canvas>
                    </div>
                    <div class="overflow-x-auto mt-auto">
                        <table class="w-full text-left stat-table">
                            <thead><tr><th>Metric</th><th>Mean</th><th>SD</th><th>CoV</th><th>95% CI</th></tr></thead>
                            <tbody id="spatialStatsBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="flex flex-col h-full">
                <div class="card h-full mb-0">
                    <div class="mb-2 border-b pb-1">
                        <h3 class="text-sm font-bold text-slate-800">Spatial Pattern (Cycle-by-Cycle)</h3>
                        <p class="text-[10px] text-slate-500">Error Bars on Dots = 95% CI. Fixed scale.</p>
                    </div>
                    <div class="h-64 w-full relative mb-2" id="containerSpatialCombined">
                        <canvas id="spatialCombinedChart"></canvas>
                    </div>
                    <div class="overflow-x-auto mt-auto max-h-48 overflow-y-auto">
                        <table class="w-full text-left stat-table">
                            <thead class="sticky top-0 bg-white"><tr><th>Cycle</th><th>L Step</th><th>R Step</th><th>Stride</th></tr></thead>
                            <tbody id="rawTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="flex flex-col h-full">
                <div class="card h-full mb-0">
                    <div class="mb-2 border-b pb-1">
                        <h3 class="text-sm font-bold text-slate-800">Stance & Swing Consistency (s)</h3>
                        <p class="text-[10px] text-slate-500">Matches Top Visualizer Colors.</p>
                    </div>
                    <div class="h-64 w-full relative mb-2" id="containerTemporal">
                        <canvas id="temporalChart"></canvas>
                    </div>
                    <div class="overflow-x-auto mt-2 mb-2">
                        <table class="w-full text-left stat-table">
                            <thead><tr><th>Metric</th><th>Mean</th><th>SD</th><th>CoV</th><th>95% CI</th></tr></thead>
                            <tbody id="temporalStatsBody"></tbody>
                        </table>
                    </div>
                    <div class="overflow-x-auto mt-auto max-h-32 overflow-y-auto">
                        <table class="w-full text-left stat-table">
                            <thead class="sticky top-0 bg-white"><tr><th>Leg</th><th>Stance</th><th>Swing</th><th>%St</th><th>%Sw</th></tr></thead>
                            <tbody id="phaseTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="logicOutput" class="mt-6 hidden">
            <div id="logicAlerts" class="space-y-2"></div>
        </div>

    </div>
</div>

<div id="infoModal" class="modal">
    <div class="modal-content">
        <div class="flex justify-between items-center mb-4 border-b pb-2">
            <h2 class="text-xl font-bold text-slate-800">Gait Analysis Tool Instructions</h2>
            <span onclick="toggleModal()" class="text-2xl cursor-pointer text-slate-400 hover:text-slate-800">&times;</span>
        </div>
        <div class="text-sm text-slate-600 space-y-4 max-h-[70vh] overflow-y-auto pr-2">
            
            <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                <h3 class="font-bold text-blue-800 mb-2">1. Data Preparation</h3>
                <p class="mb-2">This tool is designed to process the <strong>Temporal Spatial Spreadsheet</strong> provided in your course materials.</p>
                <ul class="list-disc pl-5 space-y-1 text-blue-700">
                    <li>Open your Excel file containing the gait data.</li>
                    <li>Ensure the columns include <strong>Leg</strong> (Left/Right), <strong>Events</strong> (IC/TO), and <strong>Total Time</strong>.</li>
                    <li>Highlight the range <strong>A3 to H31</strong>.</li>
                    <li>Copy the selection (Ctrl+C).</li>
                </ul>
            </div>

            <div class="bg-slate-50 p-4 rounded-lg border border-slate-200">
                <h3 class="font-bold text-slate-800 mb-2">2. Managing Datasets & Comparison</h3>
                <p class="mb-2">This dashboard allows you to load and compare two separate datasets.</p>
                <ol class="list-decimal pl-5 space-y-1">
                    <li>Click the <strong>"Data Set 1"</strong> tab at the top.</li>
                    <li>Enter a label (e.g., "Pre-Op") and paste your data.</li>
                    <li>Click <strong>Analyze Active Dataset</strong>.</li>
                    <li>Repeat for <strong>"Data Set 2"</strong>.</li>
                    <li>Use the <strong>Active View</strong> toggle buttons above the graphs to switch between them. The graph scales will remain consistent.</li>
                </ol>
            </div>

            <div>
                <h3 class="font-bold text-slate-800 mb-2">3. Understanding the Visuals</h3>
                <ul class="list-disc pl-5 space-y-2">
                    <li><strong>Gait Cycle Visualization:</strong> A graphical timeline showing Left/Right Stance and Swing phases relative to each other.
                        <ul class="list-circle pl-5 mt-1 text-xs text-slate-500">
                            <li><strong>Gait Cycle Labels:</strong> Brackets at the very top and bottom indicate the duration of full gait cycles.</li>
                            <li><strong>Stance/Swing:</strong> Colored bars show the duration and percentage of each phase.</li>
                            <li><strong>Event Labels:</strong> Text above and below the bars indicate the exact timing of Initial Contact (IC) and Toe Off (TO).</li>
                        </ul>
                    </li>
                    <li><strong>Spatial Means (Bar Chart):</strong> Compares average Step/Stride lengths. <span style="color:#10b981">Left=Green</span>, <span style="color:#ef4444">Right=Red</span>, <span style="color:#3b82f6">Stride=Blue</span>. Error bars are 95% CI.</li>
                    <li><strong>Spatial Pattern (Line Chart):</strong> Plots individual cycle data. Same color coding. Vertical lines on dots are the 95% CI.</li>
                    <li><strong>Stance & Swing Consistency:</strong> Plots durations sequentially. The colors match the Stance/Swing colors selected in the top visualizer.</li>
                </ul>
            </div>
            
            <p class="mt-4 pt-4 border-t border-slate-200 text-xs text-slate-400 font-semibold text-center">
                Tool Created by Professor Fedel
            </p>
        </div>
    </div>
</div>

<script>
    // --- 1. CONFIG & STATE ---
    const T_DIST = { 1: 12.71, 2: 4.30, 3: 3.18, 4: 2.78, 5: 2.57, 6: 2.45, 10: 2.23, 100: 1.98 };
    
    // Visualizer Color Schemes
    const SCHEMES = {
        default: {
            stanceL: '#66c2a5', swingL: '#b3e2cd', 
            stanceR: '#66c2a5', swingR: '#b3e2cd', 
            ds: '#ffffff', ssL: '#e5f5f9', ssR: '#e5f5f9'
        },
        alternate: {
            // Periwinkle/Maroon
            stanceL: '#819cf0', swingL: '#9e3b63', 
            stanceR: '#819cf0', swingR: '#9e3b63', 
            ds: '#ffffff', ssL: '#e1f5fe', ssR: '#e1f5fe'
        }
    };

    // Bottom Spatial Graph Colors (Fixed)
    const SPATIAL_COLORS = {
        L: '#10b981', // Green
        R: '#ef4444', // Red
        Stride: '#3b82f6' // Blue
    };

    let appData = {
        set1: { raw: "", label: "", processed: null },
        set2: { raw: "", label: "", processed: null }
    };
    let currentTab = 'set1';
    let charts = { spatialBar: null, spatialLine: null, temporal: null };
    let chartScales = { spatial: null, stride: null, temporal: null };

    // --- 2. UI HANDLERS ---
    function switchTab(tabId) {
        appData[currentTab].raw = document.getElementById('rawData').value;
        appData[currentTab].label = document.getElementById('datasetLabel').value;
        currentTab = tabId;
        document.getElementById('rawData').value = appData[currentTab].raw;
        document.getElementById('datasetLabel').value = appData[currentTab].label;

        updateTabStyles('tab-set1', 'tab-set2', tabId);
        updateTabStyles('toggle-set1', 'toggle-set2', tabId, 'graph-toggle-active');

        document.getElementById('toggle-set1').textContent = appData.set1.label || "Data Set 1";
        document.getElementById('toggle-set2').textContent = appData.set2.label || "Data Set 2";

        if(appData[currentTab].raw.trim().length > 0) processData();
        else document.getElementById('resultsArea').classList.add('hidden');
    }

    function updateTabStyles(id1, id2, activeId, activeClass = 'tab-active') {
        const t1 = document.getElementById(id1);
        const t2 = document.getElementById(id2);
        const isSet1 = activeId.includes('set1');
        if(isSet1) {
            t1.classList.add(activeClass); t1.classList.remove('tab-inactive');
            t2.classList.remove(activeClass); t2.classList.add('tab-inactive');
        } else {
            t2.classList.add(activeClass); t2.classList.remove('tab-inactive');
            t1.classList.remove(activeClass); t1.classList.add('tab-inactive');
        }
    }

    function toggleModal() {
        const m = document.getElementById("infoModal");
        m.style.display = (m.style.display === "block") ? "none" : "block";
    }
    window.onclick = function(e) { if (e.target == document.getElementById("infoModal")) toggleModal(); }

    // --- 3. DATA PROCESSING ---
    function processData() {
        appData[currentTab].raw = document.getElementById('rawData').value;
        appData[currentTab].label = document.getElementById('datasetLabel').value;
        
        const raw = appData[currentTab].raw;
        const label = appData[currentTab].label || (currentTab === 'set1' ? "Data Set 1" : "Data Set 2");
        
        document.getElementById('displayLabel').textContent = "Analysis: " + label;
        document.getElementById('toggle-set1').textContent = appData.set1.label || "Data Set 1";
        document.getElementById('toggle-set2').textContent = appData.set2.label || "Data Set 2";

        const processed = parseRawData(appData[currentTab].raw);
        appData[currentTab].processed = processed; 

        // Update Global Scales
        if(appData.set1.processed && appData.set2.processed) {
            updateGlobalScales();
        } else {
            // Self-scale if only one
            chartScales.spatial = getLimitsFromStats([processed.stats.sLeft, processed.stats.sRight]);
            chartScales.stride = getLimitsFromStats([processed.stats.sStride]);
            chartScales.temporal = getScaleLimits([...processed.allStances, ...processed.allSwings]);
        }

        const { events, spatial, allPhases, stats } = processed;

        const res = document.getElementById('resultsArea');
        res.classList.remove('hidden');
        document.getElementById('logicOutput').classList.remove('hidden');

        const useAlt = document.getElementById('colorSchemeToggle').checked;
        updateLegendColors(useAlt);
        const colors = useAlt ? SCHEMES.alternate : SCHEMES.default;
        
        if (events.length > 0) drawGaitVisualizer(events, allPhases, colors);
        else clearCanvas('gaitVisualizerCanvas', 'No Temporal Data');

        const hasSpatial = spatial.leftStep.length > 0;
        if (hasSpatial) {
            resetCanvas('containerSpatialBar', 'spatialBarChart');
            resetCanvas('containerSpatialCombined', 'spatialCombinedChart');
            renderSpatialBarChart(stats, chartScales.spatial, chartScales.stride);
            renderSpatialCombinedChart(spatial, stats, chartScales.spatial, chartScales.stride);
            renderTables(stats, true); 
            renderRawTable(spatial);
            renderLogic(spatial);
        } else {
            showNoData('containerSpatialBar', 'spatialStatsBody');
            showNoData('containerSpatialCombined', 'rawTableBody');
        }

        if (events.length > 0) {
            resetCanvas('containerTemporal', 'temporalChart');
            renderTemporalChart(processed.allStances, processed.allSwings, colors, chartScales.temporal);
            renderTables(stats, false); 
            renderPhaseTable(allPhases, events);
        } else {
            showNoData('containerTemporal', 'temporalStatsBody');
            document.getElementById('phaseTableBody').innerHTML = "";
        }
    }

    function parseRawData(raw) {
        const lines = raw.split('\n');
        let spatial = { leftStep: [], rightStep: [], stride: [] };
        let events = [];
        let section = 'unknown';
        lines.forEach(line => {
            const row = line.trim().split(/\t+/);
            if (row.length < 2) return;
            if (line.includes("Spatial Data")) { section = 'spatial'; return; }
            if (row[0].includes("Leg") || row[1].includes("Leg") || row[2] == "Frame") { section = 'temporal'; return; }
            if (section === 'spatial' || line.includes("Step Length") || line.includes("Stride Length")) {
                const values = row.filter(x => !isNaN(parseFloat(x)) && isFinite(x)).map(Number);
                const l = line.toLowerCase();
                if (l.includes("left step length")) spatial.leftStep = values;
                if (l.includes("right step length")) spatial.rightStep = values;
                if (l.includes("stride length")) spatial.stride = values;
            }
            if (section === 'temporal' || (!section && (row[0] === 'IC' || row[0] === 'TO' || row[0] === 'I' || row[1] === 'IC'))) {
                const rightEvt = row[0] ? row[0].trim() : "";
                const leftEvt = row[1] ? row[1].trim() : "";
                const nums = row.filter(x => !isNaN(parseFloat(x)) && isFinite(x));
                if (nums.length > 0) {
                    const time = parseFloat(nums[nums.length - 1]); 
                    if (rightEvt === 'IC' || rightEvt === 'TO') events.push({ time: time, side: 'R', type: rightEvt });
                    if (leftEvt === 'IC' || leftEvt === 'TO') events.push({ time: time, side: 'L', type: leftEvt });
                }
            }
        });
        let leftPhases = analyzeLegPhases(events.filter(e => e.side === 'L'), events);
        let rightPhases = analyzeLegPhases(events.filter(e => e.side === 'R'), events);
        let allPhases = { L: leftPhases, R: rightPhases };
        let atomicIntervals = analyzeAtomicIntervals(events); 
        let allStances = [...leftPhases.filter(p=>p.type==='stance').map(p=>p.duration), ...rightPhases.filter(p=>p.type==='stance').map(p=>p.duration)];
        let allSwings = [...leftPhases.filter(p=>p.type==='swing').map(p=>p.duration), ...rightPhases.filter(p=>p.type==='swing').map(p=>p.duration)];
        const stats = {
            sLeft: calculateStats(spatial.leftStep),
            sRight: calculateStats(spatial.rightStep),
            sStride: calculateStats(spatial.stride),
            tDS: calculateStats(atomicIntervals.ds),
            tSS: calculateStats(atomicIntervals.sw),
            tStance: calculateStats(allStances),
            tSwing: calculateStats(allSwings)
        };
        return { events, spatial, allPhases, stats, allStances, allSwings };
    }

    // --- HELPERS ---
    function updateGlobalScales() {
        const p1 = appData.set1.processed;
        const p2 = appData.set2.processed;
        
        const stepStats = [p1.stats.sLeft, p1.stats.sRight, p2.stats.sLeft, p2.stats.sRight];
        chartScales.spatial = getLimitsFromStats(stepStats);
        
        const strideStats = [p1.stats.sStride, p2.stats.sStride];
        chartScales.stride = getLimitsFromStats(strideStats);

        const allTemporal = [...p1.allStances, ...p1.allSwings, ...p2.allStances, ...p2.allSwings];
        chartScales.temporal = getScaleLimits(allTemporal);
    }

    function analyzeLegPhases(legEvents, allEvents) {
        legEvents.sort((a,b)=>a.time-b.time);
        let phases = [];
        for(let i=0; i<legEvents.length-1; i++){
            const curr = legEvents[i];
            const next = legEvents[i+1];
            let type = null;
            if(curr.type === 'IC' && next.type === 'TO') type = 'stance';
            else if(curr.type === 'TO' && next.type === 'IC') type = 'swing';
            
            if(type) {
                let cycleDur = null;
                if(type === 'stance') {
                    const nextIC = legEvents.find((e, idx) => idx > i && e.type === 'IC');
                    if(nextIC) cycleDur = nextIC.time - curr.time;
                } else {
                    const prevIC = legEvents.slice(0, i).reverse().find(e => e.type === 'IC');
                    if(prevIC) cycleDur = next.time - prevIC.time;
                }
                phases.push({ type: type, start: curr.time, end: next.time, duration: next.time-curr.time, cycle: cycleDur });
            }
        }
        return phases;
    }

    function analyzeAtomicIntervals(allEvents) {
        let s = allEvents.sort((a,b)=>a.time-b.time);
        let ds = [], sw = [];
        for(let i=0; i<s.length-1; i++){
            let dt = s[i+1].time - s[i].time;
            if(dt < 0.01) continue;
            if(s[i].type === 'IC' && s[i+1].type === 'TO') ds.push(dt);
            else if(s[i].type === 'TO' && s[i+1].type === 'IC') sw.push(dt);
        }
        return {ds, sw};
    }

    function calculateStats(arr) {
        if(!arr || arr.length===0) return { mean: 0, sd: 0, cov: 0, ciMargin: 0, ciLow: 0, ciHigh: 0 };
        const n = arr.length;
        const mean = arr.reduce((a,b)=>a+b,0)/n;
        const v = arr.reduce((a,b)=>a+Math.pow(b-mean,2),0)/(n>1?n-1:1);
        const sd = Math.sqrt(v);
        const cov = mean ? (sd/mean)*100 : 0;
        const ci = 1.96 * (sd/Math.sqrt(n));
        return { mean, sd, cov, ciMargin: ci, ciLow: mean-ci, ciHigh: mean+ci };
    }

    function getScaleLimits(values, paddingPct = 0.2) {
        if (!values || values.length === 0) return { min: 0, max: 1 };
        let dataMin = Math.min(...values); let dataMax = Math.max(...values);
        let range = dataMax - dataMin;
        if (range === 0) range = dataMax * 0.1 || 0.1; 
        const padding = range * paddingPct;
        return { min: Math.max(0, dataMin - padding), max: dataMax + padding };
    }

    function getLimitsFromStats(statsArray) {
        let maxVal = 0; let minVal = Infinity;
        statsArray.forEach(s => {
            if(s.mean === 0) return;
            const high = s.mean + s.ciMargin;
            const low = s.mean - s.ciMargin;
            if(high > maxVal) maxVal = high;
            if(low < minVal) minVal = low;
        });
        if(maxVal === 0) return { min: 0, max: 10 };
        const range = maxVal - minVal;
        const padding = range * 0.2 || maxVal * 0.1; 
        return { min: Math.max(0, minVal - padding), max: maxVal + padding };
    }

    // --- VISUALIZER DRAWING ---
    function drawGaitVisualizer(events, phases, colors) {
        const c = document.getElementById('gaitVisualizerCanvas');
        const ctx = c.getContext('2d');
        events.sort((a,b)=>a.time-b.time);
        
        const startT = events[0].time;
        const endT = events[events.length-1].time;
        const dur = endT - startT;
        
        const w = Math.max(1000, dur * 250 + 150);
        c.width = w; const h = 420; // Increased height further for neatness
        
        // Significant margins for top/bottom labels and brackets
        const m = { l: 90, t: 130 }; 
        const scale = (w - 150) / dur;
        
        ctx.clearRect(0,0,w,h);

        const barH = 50;
        const yL = m.t;
        const ySupp = yL + barH; 
        const yR = ySupp + barH; 

        // Helper: Draw Rect
        const drawBar = (t1, t2, color, text, subtext, txtColor) => {
            const x = m.l + (t1 - startT) * scale;
            const bw = (t2 - t1) * scale;
            ctx.fillStyle = color; 
            ctx.fillRect(x, y, bw, barH);
            ctx.strokeStyle = "#fff"; ctx.lineWidth=1; ctx.strokeRect(x,y,bw,barH);
            
            if(bw > 35) {
                ctx.fillStyle = txtColor || "#000";
                ctx.textAlign = "center";
                ctx.font = "bold 12px Arial";
                ctx.fillText(text, x+bw/2, y + barH/2 - 6);
                if(subtext) {
                    ctx.font = "10px Arial";
                    ctx.fillText(subtext, x+bw/2, y + barH/2 + 10);
                }
            }
        };

        // Helper: Draw Gait Cycle Bracket
        const drawBracket = (t1, t2, text, isTop) => {
            const x1 = m.l + (t1 - startT) * scale;
            const x2 = m.l + (t2 - startT) * scale;
            // Position brackets well outside the bars and labels
            const yBracket = isTop ? 30 : h - 30;
            const hD = isTop ? 10 : -10;
            
            ctx.strokeStyle = "#333"; ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x1, yBracket+hD); ctx.lineTo(x1, yBracket); 
            ctx.lineTo(x2, yBracket); 
            ctx.lineTo(x2, yBracket+hD); 
            ctx.stroke();
            ctx.fillStyle = "#333"; ctx.textAlign = "center"; ctx.font = "bold 12px Arial";
            ctx.fillText(text, (x1+x2)/2, yBracket + (isTop ? -5 : 15));
        };

        // 1. LEGS TRACKS
        let y = yL;
        ['L', 'R'].forEach(leg => {
            y = (leg === 'L') ? yL : yR;
            const cSt = (leg==='L')?colors.stanceL:colors.stanceR;
            const cSw = (leg==='L')?colors.swingL:colors.swingR;
            const lblSt = (leg==='L')?"Left Stance":"Right Stance";
            const lblSw = (leg==='L')?"Left Swing":"Right Swing";

            phases[leg].forEach(p => {
                const pct = p.cycle ? Math.round((p.duration/p.cycle)*100)+"%" : "";
                const sub = `${p.duration.toFixed(2)}s (${pct})`;
                const col = p.type==='stance'?cSt:cSw;
                const txt = p.type==='stance'?lblSt:lblSw;
                // Specific coloring per user request: Stance Black, Swing White
                const tc = p.type==='stance' ? 'black' : 'white';
                drawBar(p.start, p.end, col, txt, sub, tc);
            });
        });

        // 2. SUPPORT TRACK (Middle)
        y = ySupp;
        for(let i=0; i<events.length-1; i++){
            const curr = events[i]; const next = events[i+1];
            if(curr.type==='IC' && next.type==='TO') {
                drawBar(curr.time, next.time, colors.ds, "Double", "Support", "#333");
                const x = m.l + (curr.time-startT)*scale; const bw = (next.time-curr.time)*scale;
                ctx.strokeStyle="#ccc"; ctx.strokeRect(x,y,bw,barH); 
            } else if(curr.type==='TO' && next.type==='IC') {
                const txt = (curr.side==='L')?"Right SS":"Left SS";
                const col = (curr.side==='L')?colors.ssR:colors.ssL;
                drawBar(curr.time, next.time, col, txt, "", "#333");
            }
        }

        // 3. FULL HEIGHT EVENT LINES & LABELS (Cleaned up positioning)
        ctx.textAlign = "center";
        ctx.font = "bold 10px Segoe UI, Arial"; // Slightly smaller font for neatness
        events.forEach(e => {
            const x = m.l + (e.time - startT) * scale;
            ctx.strokeStyle = "#333"; ctx.lineWidth = 1.5; 
            ctx.beginPath(); 
            ctx.moveTo(x, yL); ctx.lineTo(x, yR + barH); ctx.stroke();

            ctx.fillStyle = "#000"; 
            const sideFull = (e.side==='L')?"Left":"Right";
            const typeFull = (e.type==='IC')?"initial contact":"toe off";
            
            // Position labels clearly above top bar or below bottom bar
            let yBase;
            if(e.side === 'L') {
                 yBase = yL - 45; // Above top bar
            } else {
                 yBase = yR + barH + 15; // Below bottom bar
            }

            ctx.fillText(sideFull, x, yBase);
            ctx.fillText(typeFull, x, yBase + 12);
            ctx.fillStyle = "#666"; ctx.font = "10px monospace";
            ctx.fillText(e.time.toFixed(2)+"s", x, yBase + 24);
            ctx.font = "bold 10px Segoe UI, Arial"; // Reset font for next loop
        });

        // 4. GAIT CYCLE BRACKETS (Both Legs, positioned at far extremes)
        ['L', 'R'].forEach(leg => {
            const ics = events.filter(e => e.side === leg && e.type === 'IC');
            for(let i=0; i<ics.length-1; i++) {
                const cycleDur = ics[i+1].time - ics[i].time;
                drawBracket(ics[i].time, ics[i+1].time, `Gait Cycle: ${cycleDur.toFixed(2)}s`, leg === 'L');
            }
        });

        // Row Headers
        ctx.textAlign = "right"; ctx.font = "bold 14px Arial"; ctx.fillStyle = "#1e293b";
        ctx.fillText("Left Leg", m.l - 15, yL + barH/2 + 5);
        ctx.fillText("Support", m.l - 15, ySupp + barH/2 + 5);
        ctx.fillText("Right Leg", m.l - 15, yR + barH/2 + 5);
    }

    // --- RENDERERS ---
    function resetCanvas(cId, canId) {
        document.getElementById(cId).innerHTML = `<canvas id="${canId}"></canvas>`;
    }
    function clearCanvas(id, t) {
        const x = document.getElementById(id).getContext('2d');
        x.clearRect(0,0,1000,420); x.font="14px Arial"; x.fillStyle="#999"; x.textAlign="center"; x.fillText(t, 500, 210);
    }
    function updateLegendColors(useAlt) {
        const c = useAlt ? SCHEMES.alternate : SCHEMES.default;
        document.getElementById('legendStance').style.backgroundColor = c.stanceL;
        document.getElementById('legendSwing').style.backgroundColor = c.swingL;
    }
    function showNoData(cId, tId) {
        document.getElementById(cId).innerHTML = '<div class="no-data">⚠️ No Data</div>';
        if(tId) document.getElementById(tId).innerHTML = '<tr><td colspan="5" class="text-center text-slate-400 py-2">No Data</td></tr>';
    }

    function renderSpatialBarChart(stats, spatialScale, strideScale) {
        if(charts.spatialBar) charts.spatialBar.destroy();
        const leftLims = spatialScale || getLimitsFromStats([stats.sLeft, stats.sRight]);
        const rightLims = strideScale || getLimitsFromStats([stats.sStride]);
        
        charts.spatialBar = new Chart(document.getElementById('spatialBarChart'), {
            type: 'bar',
            data: {
                labels: ['Left Step', 'Right Step', 'Stride'],
                datasets: [
                    { label: 'Step', data: [stats.sLeft.mean, stats.sRight.mean, null], backgroundColor: [SPATIAL_COLORS.L, SPATIAL_COLORS.R, SPATIAL_COLORS.L], borderWidth: 1, errorBars: [stats.sLeft.ciMargin, stats.sRight.ciMargin, null], yAxisID: 'y', order: 2 },
                    { label: 'Stride', data: [null, null, stats.sStride.mean], backgroundColor: SPATIAL_COLORS.Stride, borderWidth: 1, errorBars: [null, null, stats.sStride.ciMargin], yAxisID: 'y1', order: 1 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { position: 'left', min: leftLims.min, max: leftLims.max }, y1: { position: 'right', grid: {drawOnChartArea:false}, min: rightLims.min, max: rightLims.max } }, plugins: { legend: { display: false } } },
            plugins: [{ id: 'errorBar', afterDatasetsDraw: (chart) => {
                const { ctx, scales } = chart; chart.data.datasets.forEach((d, i) => { if(!d.errorBars) return; const meta = chart.getDatasetMeta(i); meta.data.forEach((bar, idx) => { const v = d.data[idx]; const m = d.errorBars[idx]; if(!m) return; const x = bar.x; const yHigh = scales[d.yAxisID].getPixelForValue(v+m); const yLow = scales[d.yAxisID].getPixelForValue(v-m); ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#333'; ctx.beginPath(); ctx.moveTo(x, yLow); ctx.lineTo(x, yHigh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-6, yLow); ctx.lineTo(x+6, yLow); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-6, yHigh); ctx.lineTo(x+6, yHigh); ctx.stroke(); ctx.restore(); }); });
            }}]
        });
    }

    function renderSpatialCombinedChart(spatial, stats, spatialScale, strideScale) {
        if(charts.spatialLine) charts.spatialLine.destroy();
        const m = Math.max(spatial.leftStep.length, spatial.rightStep.length, spatial.stride.length);
        const l = Array.from({length: m}, (_,i)=>i+1);
        const leftLims = spatialScale || getLimitsFromStats([stats.sLeft, stats.sRight]);
        const rightLims = strideScale || getLimitsFromStats([stats.sStride]);
        const lMarg = Array(spatial.leftStep.length).fill(stats.sLeft.ciMargin);
        const rMarg = Array(spatial.rightStep.length).fill(stats.sRight.ciMargin);
        const sMarg = Array(spatial.stride.length).fill(stats.sStride.ciMargin);

        charts.spatialLine = new Chart(document.getElementById('spatialCombinedChart'), {
            type: 'line',
            data: {
                labels: l,
                datasets: [
                    { label: 'L Step', data: spatial.leftStep, borderColor: SPATIAL_COLORS.L, backgroundColor:SPATIAL_COLORS.L, tension: 0.1, yAxisID: 'y', pointRadius: 4, errorBars: lMarg },
                    { label: 'R Step', data: spatial.rightStep, borderColor: SPATIAL_COLORS.R, backgroundColor:SPATIAL_COLORS.R, tension: 0.1, yAxisID: 'y', pointRadius: 4, errorBars: rMarg },
                    { label: 'Stride', data: spatial.stride, borderColor: SPATIAL_COLORS.Stride, backgroundColor:SPATIAL_COLORS.Stride, borderDash: [2, 2], tension: 0.1, yAxisID: 'y1', pointRadius: 4, errorBars: sMarg }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { position: 'left', min: leftLims.min, max: leftLims.max }, y1: { position: 'right', grid: {drawOnChartArea:false}, min: rightLims.min, max: rightLims.max } }, plugins: { legend: { labels: {boxWidth:8, usePointStyle:true} } } },
            plugins: [{ id: 'pointErrorBar', afterDatasetsDraw: (chart) => {
                const { ctx, scales } = chart; chart.data.datasets.forEach((d, i) => { if(!d.errorBars) return; const meta = chart.getDatasetMeta(i); meta.data.forEach((pt, idx) => { const v = d.data[idx]; const m = d.errorBars[idx]; if(!m) return; const x = pt.x; const yHigh = scales[d.yAxisID].getPixelForValue(v+m); const yLow = scales[d.yAxisID].getPixelForValue(v-m); ctx.save(); ctx.lineWidth=1.5; ctx.strokeStyle=d.borderColor; ctx.beginPath(); ctx.moveTo(x, yLow); ctx.lineTo(x, yHigh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-3, yLow); ctx.lineTo(x+3, yLow); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-3, yHigh); ctx.lineTo(x+3, yHigh); ctx.stroke(); ctx.restore(); }); });
            }}]
        });
    }

    function renderTemporalChart(stances, swings, colors, temporalScale) {
        if(charts.temporal) charts.temporal.destroy();
        const len = Math.min(stances.length, swings.length);
        const l = Array.from({length: len}, (_,i)=>i+1);
        const lims = temporalScale || getScaleLimits([...stances, ...swings]);

        charts.temporal = new Chart(document.getElementById('temporalChart'), {
            type: 'line',
            data: {
                labels: l,
                datasets: [
                    { label: 'Stance', data: stances.slice(0,len), borderColor: colors.stanceL, backgroundColor: colors.stanceL, tension: 0.2, pointRadius: 3 },
                    { label: 'Swing', data: swings.slice(0,len), borderColor: colors.swingL, backgroundColor: colors.swingL, tension: 0.2, pointRadius: 3 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { min: lims.min, max: lims.max } } }
        });
    }

    function renderTables(stats, isS) {
        const d = isS ? 1 : 2;
        const row = (l, s) => `<tr class="hover:bg-slate-50"><td class="font-medium text-slate-700">${l}</td><td class="font-bold">${s.mean.toFixed(d)}</td><td>${s.sd.toFixed(2)}</td><td class="text-blue-600 font-bold">${s.cov.toFixed(1)}%</td><td class="text-[10px] text-slate-500 whitespace-nowrap">${s.ciLow.toFixed(d)} - ${s.ciHigh.toFixed(d)}</td></tr>`;
        if(isS) document.getElementById('spatialStatsBody').innerHTML = row('L Step', stats.sLeft) + row('R Step', stats.sRight) + row('Stride', stats.sStride);
        else document.getElementById('temporalStatsBody').innerHTML = row('Stance', stats.tStance) + row('Swing', stats.tSwing);
    }

    function renderRawTable(spatial) {
        const b = document.getElementById('rawTableBody'); b.innerHTML = "";
        const m = Math.max(spatial.leftStep.length, spatial.rightStep.length, spatial.stride.length);
        for(let i=0; i<m; i++) b.innerHTML += `<tr class="hover:bg-slate-50 border-b border-slate-100"><td class="text-slate-500">${i+1}</td><td style="color:${SPATIAL_COLORS.L}" class="font-medium">${spatial.leftStep[i]||"-"}</td><td style="color:${SPATIAL_COLORS.R}" class="font-medium">${spatial.rightStep[i]||"-"}</td><td style="color:${SPATIAL_COLORS.Stride}" class="font-medium">${spatial.stride[i]||"-"}</td></tr>`;
    }

    function renderPhaseTable(phases, events) {
        const b = document.getElementById('phaseTableBody'); b.innerHTML = "";
        const ren=(l,pl,cl)=>{pl.forEach(p=>{const stP=p.cycle?((p.duration/p.cycle)*100).toFixed(0)+"%":"-";b.innerHTML+=`<tr class="hover:bg-slate-50 border-b border-slate-100"><td class="font-bold ${cl}">${l} ${p.type}</td><td>${p.type==='stance'?p.duration.toFixed(2):'-'}</td><td>${p.type==='swing'?p.duration.toFixed(2):'-'}</td><td class="text-amber-600 font-bold">${p.type==='stance'?stP:'-'}</td><td class="text-blue-600 font-bold">${p.type==='swing'?stP:'-'}</td></tr>`;});};ren('L',phases.L,'text-green-600');ren('R',phases.R,'text-red-600');
    }

    function renderLogic(s) {
        const d=Math.abs(calculateStats(s.leftStep).mean-calculateStats(s.rightStep).mean);
        document.getElementById('logicAlerts').innerHTML=d>5?`<div class="p-3 bg-red-100 border-l-4 border-red-500 text-red-700 rounded text-sm"><strong>⚠️ Asymmetry:</strong> L/R step difference: ${d.toFixed(1)}cm.</div>`:`<div class="p-3 bg-green-100 border-l-4 border-green-500 text-green-700 rounded text-sm">✅ Data consistent.</div>`;
    }

    function loadDemoData(){document.getElementById('rawData').value=`Right\tLeft\tFrame\tInt\tTot\tTime\nIC\t\t100\t0\t0\t0.00\n\tTO\t136\t36\t36\t0.15\n\tIC\t244\t108\t144\t0.60\nTO\t\t280\t36\t180\t0.75\nIC\t\t388\t108\t288\t1.20\n\tTO\t424\t36\t324\t1.35\n\tIC\t532\t108\t432\t1.80\nTO\t\t568\t36\t468\t1.95\nIC\t\t676\t108\t576\t2.40\n\nSpatial Data\nRight IC\tLeft IC\tLeft Step Length\t72.5\t73.1\t72.8\nLeft IC\tRight IC\tRight Step Length\t71.8\t72.2\t72.0\nRight IC\tRight IC\tRight Stride Length\t144.3\t145.3\t144.8`;processData();}
</script>
</body>
</html>